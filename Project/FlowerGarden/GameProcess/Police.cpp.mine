#include "Police.h"
#include "PoliceState.h"
#include "FSM.h"

#include "Transform.h"

Police::Police(Transform* playerTransform, Transform* policeTrasform) 
	: m_curState()
	, m_FSM()
	, m_playerTransform(playerTransform)
	, m_policeTrasnform(policeTrasform)
	, m_police()
	, m_redPolice()
	, m_bluePolice()
	, m_pathManager(nullptr)
	, m_index(0)
	, m_spriteIndex(4)
	, m_preDirection(1.f, -1.f)
	, m_direction(0.f, 0.f)
{
	Init();
}

Police::~Police()
{
	delete m_FSM;
	delete m_police; 
	delete m_redPolice;
	delete m_bluePolice;
}

void Police::Init()
{
	m_curState = State::Idle;
	m_FSM = new FSM(new PoliceIdleState(this));
}

void Police::FixedUpdate()
{

}

void Police::Update(float deltaTime)
{
	switch (m_curState)
	{
	case Police::State::Idle:
		if (IsRecognizePlayer())
		{
			ChangeState(State::Chasing);
		}
		break;
	case Police::State::Chasing:
		if (!IsRecognizePlayer())
		{
			ChangeState(State::Idle);
		}
		break;
	case Police::State::Collision:
		break;
	}

	m_FSM->UpdateState();

	static float time = 0;

	time += deltaTime;
	if (time > 1)
	{
		m_index++;
		time = 0;
	}

	if (m_index >= 32)
	{
		m_index = 0;
	}
}

void Police::LateUpdate()
{

}

void Police::PreRender()
{

}

void Police::Render(DirectY* directY)
{

	// 인덱스 변경
	if ((m_preDirection.x * m_direction.x < 0.f) || (m_preDirection.y * m_direction.y < 0.f))
	{
		float crossProduct = m_preDirection.Cross(m_direction);
		// 우회전
		if (crossProduct > 0.f)
		{
			m_spriteIndex += 1;
		}
		// 좌회전
		else if (crossProduct < 0.f)
		{
			m_spriteIndex -= 1;
		}
	}

	// 인덱스 보정
	if (m_spriteIndex < 0)
	{
		m_spriteIndex += 31;
	}
	m_spriteIndex %= 32;

	// 이전 방향 업뎃
	if (m_direction.x > 0.f && m_direction.y > 0.f && m_spriteIndex == 4 ||
		m_direction.x < 0.f && m_direction.y > 0.f && m_spriteIndex == 12 ||
		m_direction.x < 0.f && m_direction.y < 0.f && m_spriteIndex == 20 ||
		m_direction.x > 0.f && m_direction.y < 0.f && m_spriteIndex == 28)
	{
		m_preDirection = m_direction;
	}

	switch (m_curState)
	{
	case Police::State::Idle:
		directY->DrawBitmap(m_police->GetSprite(m_spriteIndex));
		directY->DrawText(0, 40, 20, TextAlignMent::LEFT, L"Verdana", "%s", "Idle");
		break;
	case Police::State::Chasing:
	{
		if (m_index % 2 == 0)
		{
			directY->DrawBitmap(m_bluePolice->GetSprite(m_spriteIndex));
		}
		else if (m_index % 2 == 1)
		{
			directY->DrawBitmap(m_redPolice->GetSprite(m_spriteIndex));
		}
	}
		directY->DrawText(0, 40, 20, TextAlignMent::LEFT, L"Verdana", "%s", "Chasing");
		break;
	case Police::State::Collision:
		directY->DrawBitmap(m_police->GetSprite(m_index));
		directY->DrawText(0, 40, 20, TextAlignMent::LEFT, L"Verdana", "%s", "Collision");
		break;
	}

	m_FSM->RenderState(directY);
}

void Police::PostRender(DirectY* directY)
{

}

void Police::Release()
{

}

ElementType Police::GetElementType() const
{
	return ElementType::Script;
}

GameObject* Police::GetGameObject() const
{
	return m_gameObject;
}

void Police::SetGameObject(GameObject* gameObject)
{
	m_gameObject = gameObject;
}

void Police::ChangeState(State nextState)
{
	m_curState = nextState;
	switch (m_curState)
	{
	case Police::State::Idle:
		m_FSM->ChangeState(new PoliceIdleState(this));
		break;
	case Police::State::Chasing:
		m_FSM->ChangeState(new PoliceChasingState(this));
		break;
	case Police::State::Collision:
		m_FSM->ChangeState(new PoliceChasingState(this));
		break;
	default:
		break;
	}
}

bool Police::IsRecognizePlayer()
{
	// 일단은 거리로 대충 해놓기
	int playerX = std::abs((int)m_playerTransform->GetScreenPosition().x);
	int playerY = std::abs((int)m_playerTransform->GetScreenPosition().y);

	int policeX = std::abs((int)m_policeTrasnform->GetScreenPosition().x);
	int policeY = std::abs((int)m_policeTrasnform->GetScreenPosition().y);

	int maxX = max(std::abs((int)m_playerTransform->GetScreenPosition().x), std::abs((int)m_policeTrasnform->GetScreenPosition().x));
	int minX = min(std::abs((int)m_playerTransform->GetScreenPosition().x), std::abs((int)m_policeTrasnform->GetScreenPosition().x));

	int maxY = max(std::abs((int)m_playerTransform->GetScreenPosition().y), std::abs((int)m_policeTrasnform->GetScreenPosition().y));
	int minY = min(std::abs((int)m_playerTransform->GetScreenPosition().y), std::abs((int)m_policeTrasnform->GetScreenPosition().y));

	// 자기 포지션도 가지고 있어야 함
	if (maxX - minX < 1800 && maxY - minY < 1400)
	{
		return true;
	}
	return false;
}

bool Police::IsCollision()
{
	return false;
}